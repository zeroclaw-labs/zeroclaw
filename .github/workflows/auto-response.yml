name: Auto Response

on:
  issues:
    types: [opened, labeled]
  pull_request_target:
    types: [opened, labeled]

permissions: {}

jobs:
  first-interaction:
    if: github.event.action == 'opened'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Greet first-time contributors
        uses: actions/first-interaction@v1
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          issue-message: |
            Thanks for opening this issue.

            Before maintainers triage it, please confirm:
            - Repro steps are complete and run on latest `main`
            - Environment details are included (OS, Rust version, ZeroClaw version)
            - Sensitive values are redacted

            This helps us keep issue throughput high and response latency low.
          pr-message: |
            Thanks for contributing to ZeroClaw.

            For faster review, please ensure:
            - PR template sections are fully completed
            - `cargo fmt --all -- --check`, `cargo clippy --all-targets -- -D warnings`, and `cargo test` are included
            - If automation/agents were used heavily, add brief workflow notes
            - Scope is focused (prefer one concern per PR)

            See `CONTRIBUTING.md` and `docs/pr-workflow.md` for full collaboration rules.

  labeled-routes:
    if: github.event.action == 'labeled'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Handle label-driven responses
        uses: actions/github-script@v7
        with:
          script: |
            const label = context.payload.label?.name;
            if (!label) return;

            const issue = context.payload.issue;
            const pullRequest = context.payload.pull_request;
            const target = issue ?? pullRequest;
            if (!target) return;

            const isIssue = Boolean(issue);
            const issueNumber = target.number;

            const rules = [
              {
                label: "r:support",
                close: true,
                closeIssuesOnly: true,
                closeReason: "not_planned",
                message:
                  "This looks like a usage/support request. Please use README + docs first, then open a focused bug with repro details if behavior is incorrect.",
              },
              {
                label: "r:needs-repro",
                close: false,
                message:
                  "Thanks for the report. Please add deterministic repro steps, exact environment, and redacted logs so maintainers can triage quickly.",
              },
              {
                label: "invalid",
                close: true,
                closeReason: "not_planned",
                message:
                  "Closing as invalid based on current information. If this is still relevant, open a new issue with updated evidence and reproducible steps.",
              },
              {
                label: "duplicate",
                close: true,
                closeReason: "not_planned",
                message:
                  "Closing as duplicate. Please continue discussion in the canonical linked issue/PR.",
              },
            ];

            const rule = rules.find((entry) => entry.label === label);
            if (!rule) return;

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: rule.message,
            });

            if (!rule.close) return;
            if (rule.closeIssuesOnly && !isIssue) return;

            if (isIssue) {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                state: "closed",
                state_reason: rule.closeReason || "not_planned",
              });
            } else {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issueNumber,
                state: "closed",
              });
            }
