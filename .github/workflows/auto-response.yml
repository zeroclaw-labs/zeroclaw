name: Auto Response

on:
  issues:
    types: [opened, reopened, labeled]
  pull_request_target:
    types: [opened, labeled]

permissions: {}

jobs:
  trusted-contributor-issues:
    if: github.event_name == 'issues' && (github.event.action == 'opened' || github.event.action == 'reopened')
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Apply trusted contributor label for issue author
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue = context.payload.issue;
            const trustedContributorLabel = "trusted contributor";
            const trustedContributorMinMergedPRs = 5;

            if (!issue) return;
            const author = issue.user;
            if (!author || author.type === "Bot") return;

            let mergedCount = 0;
            try {
              const { data: mergedSearch } = await github.rest.search.issuesAndPullRequests({
                q: `repo:${owner}/${repo} is:pr is:merged author:${author.login}`,
                per_page: 1,
              });
              mergedCount = mergedSearch.total_count || 0;
            } catch (error) {
              core.warning(`failed to evaluate trusted contributor status: ${error.message}`);
              return;
            }

            if (mergedCount < trustedContributorMinMergedPRs) {
              return;
            }

            try {
              await github.rest.issues.getLabel({ owner, repo, name: trustedContributorLabel });
            } catch (error) {
              if (error.status !== 404) throw error;
              await github.rest.issues.createLabel({
                owner,
                repo,
                name: trustedContributorLabel,
                color: "0E8A16",
              });
            }

            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: issue.number,
              labels: [trustedContributorLabel],
            });

  first-interaction:
    if: github.event.action == 'opened'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Greet first-time contributors
        uses: actions/first-interaction@v1
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          issue-message: |
            Thanks for opening this issue.

            Before maintainers triage it, please confirm:
            - Repro steps are complete and run on latest `main`
            - Environment details are included (OS, Rust version, ZeroClaw version)
            - Sensitive values are redacted

            This helps us keep issue throughput high and response latency low.
          pr-message: |
            Thanks for contributing to ZeroClaw.

            For faster review, please ensure:
            - PR template sections are fully completed
            - `cargo fmt --all -- --check`, `cargo clippy --all-targets -- -D warnings`, and `cargo test` are included
            - If automation/agents were used heavily, add brief workflow notes
            - Scope is focused (prefer one concern per PR)

            See `CONTRIBUTING.md` and `docs/pr-workflow.md` for full collaboration rules.

  labeled-routes:
    if: github.event.action == 'labeled'
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
    steps:
      - name: Handle label-driven responses
        uses: actions/github-script@v7
        with:
          script: |
            const label = context.payload.label?.name;
            if (!label) return;

            const issue = context.payload.issue;
            const pullRequest = context.payload.pull_request;
            const target = issue ?? pullRequest;
            if (!target) return;

            const isIssue = Boolean(issue);
            const issueNumber = target.number;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const rules = [
              {
                label: "r:support",
                close: true,
                closeIssuesOnly: true,
                closeReason: "not_planned",
                message:
                  "This looks like a usage/support request. Please use README + docs first, then open a focused bug with repro details if behavior is incorrect.",
              },
              {
                label: "r:needs-repro",
                close: false,
                message:
                  "Thanks for the report. Please add deterministic repro steps, exact environment, and redacted logs so maintainers can triage quickly.",
              },
              {
                label: "invalid",
                close: true,
                closeIssuesOnly: true,
                closeReason: "not_planned",
                message:
                  "Closing as invalid based on current information. If this is still relevant, open a new issue with updated evidence and reproducible steps.",
              },
              {
                label: "duplicate",
                close: true,
                closeIssuesOnly: true,
                closeReason: "not_planned",
                message:
                  "Closing as duplicate. Please continue discussion in the canonical linked issue/PR.",
              },
            ];

            const rule = rules.find((entry) => entry.label === label);
            if (!rule) return;

            const marker = `<!-- auto-response:${rule.label} -->`;
            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: issueNumber,
              per_page: 100,
            });

            const alreadyCommented = comments.some((comment) =>
              (comment.body || "").includes(marker)
            );

            if (!alreadyCommented) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issueNumber,
                body: `${rule.message}\n\n${marker}`,
              });
            }

            if (!rule.close) return;
            if (rule.closeIssuesOnly && !isIssue) return;
            if (target.state === "closed") return;

            if (isIssue) {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                state: "closed",
                state_reason: rule.closeReason || "not_planned",
              });
            } else {
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issueNumber,
                state: "closed",
              });
            }
