//! Integrator â€” generates ZeroClaw-standard SKILL.toml + SKILL.md from scout results.

use std::fs;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};
use chrono::Utc;
use tracing::info;

use super::scout::ScoutResult;

// ---------------------------------------------------------------------------
// Integrator
// ---------------------------------------------------------------------------

pub struct Integrator {
    output_dir: PathBuf,
}

impl Integrator {
    pub fn new(output_dir: String) -> Self {
        Self {
            output_dir: PathBuf::from(output_dir),
        }
    }

    /// Write SKILL.toml and SKILL.md for the given candidate.
    pub fn integrate(&self, candidate: &ScoutResult) -> Result<PathBuf> {
        let skill_dir = self.output_dir.join(&candidate.name);
        fs::create_dir_all(&skill_dir)
            .with_context(|| format!("Failed to create dir: {}", skill_dir.display()))?;

        let toml_path = skill_dir.join("SKILL.toml");
        let md_path = skill_dir.join("SKILL.md");

        let toml_content = self.generate_toml(candidate);
        let md_content = self.generate_md(candidate);

        fs::write(&toml_path, &toml_content)
            .with_context(|| format!("Failed to write {}", toml_path.display()))?;
        fs::write(&md_path, &md_content)
            .with_context(|| format!("Failed to write {}", md_path.display()))?;

        info!(
            skill = candidate.name.as_str(),
            path = %skill_dir.display(),
            "Integrated skill"
        );

        Ok(skill_dir)
    }

    // -- Generators ---------------------------------------------------------

    fn generate_toml(&self, c: &ScoutResult) -> String {
        let lang = c.language.as_deref().unwrap_or("unknown");
        let updated = c
            .updated_at
            .map(|d| d.format("%Y-%m-%d").to_string())
            .unwrap_or_else(|| "unknown".into());

        format!(
            r#"# Auto-generated by SkillForge on {now}

[skill]
name = "{name}"
version = "0.1.0"
description = "{description}"
source = "{url}"
owner = "{owner}"
language = "{lang}"
license = {license}
stars = {stars}
updated_at = "{updated}"

[skill.requirements]
runtime = "zeroclaw >= 0.1"

[skill.metadata]
auto_integrated = true
forge_timestamp = "{now}"
"#,
            now = Utc::now().format("%Y-%m-%dT%H:%M:%SZ"),
            name = escape_toml(&c.name),
            description = escape_toml(&c.description),
            url = c.url,
            owner = escape_toml(&c.owner),
            lang = lang,
            license = if c.has_license { "true" } else { "false" },
            stars = c.stars,
            updated = updated,
        )
    }

    fn generate_md(&self, c: &ScoutResult) -> String {
        let lang = c.language.as_deref().unwrap_or("unknown");
        format!(
            r#"# {name}

> Auto-generated by SkillForge

## Overview

- **Source**: [{url}]({url})
- **Owner**: {owner}
- **Language**: {lang}
- **Stars**: {stars}
- **License**: {license}

## Description

{description}

## Usage

```toml
# Add to your ZeroClaw config:
[skills.{name}]
enabled = true
```

## Notes

This manifest was auto-generated from repository metadata.
Review before enabling in production.
"#,
            name = c.name,
            url = c.url,
            owner = c.owner,
            lang = lang,
            stars = c.stars,
            license = if c.has_license { "yes" } else { "unknown" },
            description = c.description,
        )
    }
}

/// Escape double-quotes for TOML string values.
fn escape_toml(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
    use crate::skillforge::scout::{ScoutResult, ScoutSource};
    use std::fs;

    fn sample_candidate() -> ScoutResult {
        ScoutResult {
            name: "test-skill".into(),
            url: "https://github.com/user/test-skill".into(),
            description: "A test skill for unit tests".into(),
            stars: 42,
            language: Some("Rust".into()),
            updated_at: Some(Utc::now()),
            source: ScoutSource::GitHub,
            owner: "user".into(),
            has_license: true,
        }
    }

    #[test]
    fn integrate_creates_files() {
        let tmp = std::env::temp_dir().join("zeroclaw-test-integrate");
        let _ = fs::remove_dir_all(&tmp);

        let integrator = Integrator::new(tmp.to_string_lossy().into_owned());
        let c = sample_candidate();
        let path = integrator.integrate(&c).unwrap();

        assert!(path.join("SKILL.toml").exists());
        assert!(path.join("SKILL.md").exists());

        let toml = fs::read_to_string(path.join("SKILL.toml")).unwrap();
        assert!(toml.contains("name = \"test-skill\""));
        assert!(toml.contains("stars = 42"));

        let md = fs::read_to_string(path.join("SKILL.md")).unwrap();
        assert!(md.contains("# test-skill"));
        assert!(md.contains("A test skill for unit tests"));

        let _ = fs::remove_dir_all(&tmp);
    }

    #[test]
    fn escape_toml_handles_quotes() {
        assert_eq!(escape_toml(r#"say "hello""#), r#"say \"hello\""#);
        assert_eq!(escape_toml(r"back\slash"), r"back\\slash");
    }
}
